#!/usr/bin/env -S deno run --allow-env

/**
 * Compare Analytics Requests
 * 
 * This script compares the URLs generated by getJsonFromDHIS2 and getAnalyticsFromDHIS2
 * to ensure they produce identical requests for the same parameters.
 */

// Test parameters

console.log("Comparing Analytics Request URLs");
console.log("=" .repeat(60));

// Test parameters
const testParams = {
  dataElementIds: ["DE1", "DE2", "DE3"],
  orgUnitIds: ["OU1", "OU2"],
  periods: ["202301", "202302"]
};

// Method 1: Original getJsonFromDHIS2 URL building
function buildOriginalUrl(params: typeof testParams): string {
  const baseUrl = "https://example.dhis2.org/dhis";
  const dimensions = [
    `dimension=dx:${params.dataElementIds.join(";")}`,
    `dimension=pe:${params.periods.join(";")}`,
    `dimension=ou:${params.orgUnitIds.join(";")}`,
  ].join("&");
  
  return `${baseUrl}/api/analytics.json?${dimensions}`;
}

// Method 2: New getAnalyticsFromDHIS2 URL building
function buildNewUrl(params: typeof testParams): string {
  const searchParams = new URLSearchParams();
  
  // Build dimensions - maintain dx, pe, ou order for compatibility
  const dimensions: string[] = [];
  
  if (params.dataElementIds && params.dataElementIds.length > 0) {
    dimensions.push(`dimension=dx:${params.dataElementIds.join(";")}`);
  }
  
  if (params.periods && params.periods.length > 0) {
    dimensions.push(`dimension=pe:${params.periods.join(";")}`);
  }
  
  if (params.orgUnitIds && params.orgUnitIds.length > 0) {
    dimensions.push(`dimension=ou:${params.orgUnitIds.join(";")}`);
  }
  
  // Add dimensions to params
  dimensions.forEach(dim => {
    const [key, value] = dim.split("=");
    searchParams.append(key, value);
  });
  
  // Build URL manually like base_fetcher does
  const baseUrl = "https://example.dhis2.org/dhis";
  const url = new URL(`${baseUrl}/api/analytics.json`);
  
  searchParams.forEach((value, key) => {
    url.searchParams.append(key, value);
  });
  
  return url.toString();
}

// Compare the URLs
const originalUrl = buildOriginalUrl(testParams);
const newUrl = buildNewUrl(testParams);

console.log("\nOriginal URL (getJsonFromDHIS2):");
console.log(originalUrl);

console.log("\nNew URL (getAnalyticsFromDHIS2):");
console.log(newUrl);

// Parse and compare query parameters
function parseQueryParams(url: string): Map<string, string[]> {
  const urlObj = new URL(url);
  const params = new Map<string, string[]>();
  
  urlObj.searchParams.forEach((value, key) => {
    if (!params.has(key)) {
      params.set(key, []);
    }
    params.get(key)!.push(value);
  });
  
  return params;
}

const originalParams = parseQueryParams(originalUrl);
const newParams = parseQueryParams(newUrl);

console.log("\n" + "=".repeat(60));
console.log("Query Parameter Comparison:");
console.log("-".repeat(60));

// Check if parameters match
let differencesFound = false;

// Check original parameters
originalParams.forEach((values, key) => {
  const newValues = newParams.get(key);
  console.log(`\nParameter: ${key}`);
  console.log(`  Original: ${values.join(", ")}`);
  console.log(`  New:      ${newValues ? newValues.join(", ") : "MISSING"}`);
  
  if (!newValues || values.join(",") !== newValues.join(",")) {
    differencesFound = true;
    console.log(`  ⚠️  DIFFERENCE FOUND!`);
  } else {
    console.log(`  ✅ Match`);
  }
});

// Check for extra parameters in new
newParams.forEach((values, key) => {
  if (!originalParams.has(key)) {
    console.log(`\nParameter: ${key}`);
    console.log(`  Original: MISSING`);
    console.log(`  New:      ${values.join(", ")}`);
    console.log(`  ⚠️  EXTRA PARAMETER IN NEW!`);
    differencesFound = true;
  }
});

// Test order of dimensions (DHIS2 cares about this)
console.log("\n" + "=".repeat(60));
console.log("Dimension Order Check:");
console.log("-".repeat(60));

const originalDimensions = originalUrl.split("?")[1].split("&").filter(p => p.startsWith("dimension="));
const newDimensions = newUrl.split("?")[1].split("&").filter(p => p.startsWith("dimension="));

console.log("\nOriginal dimension order:");
originalDimensions.forEach((dim, i) => {
  console.log(`  ${i + 1}. ${dim}`);
});

console.log("\nNew dimension order:");
newDimensions.forEach((dim, i) => {
  console.log(`  ${i + 1}. ${dim}`);
});

// Check if order matches
const orderMatches = originalDimensions.join("&") === newDimensions.join("&");
console.log(`\nOrder matches: ${orderMatches ? "✅ Yes" : "❌ No"}`);

// Check if URLs are functionally equivalent (ignoring encoding)
console.log("\n" + "=".repeat(60));
console.log("URL Encoding Check:");
console.log("-".repeat(60));

// Decode both URLs for comparison
const decodedOriginal = decodeURIComponent(originalUrl);
const decodedNew = decodeURIComponent(newUrl);

console.log("\nDecoded URLs match: " + (decodedOriginal === decodedNew ? "✅ Yes" : "❌ No"));

if (decodedOriginal !== decodedNew) {
  console.log("\nDecoded Original:");
  console.log(decodedOriginal);
  console.log("\nDecoded New:");
  console.log(decodedNew);
}

// Final verdict
console.log("\n" + "=".repeat(60));
console.log("FINAL VERDICT:");
console.log("-".repeat(60));

if (decodedOriginal === decodedNew) {
  console.log("✅ URLs are FUNCTIONALLY IDENTICAL!");
  console.log("   The only difference is URL encoding (: vs %3A, ; vs %3B)");
  console.log("   Both formats are valid and will work with DHIS2.");
  console.log("\n✅ SAFE to use new implementation!");
} else if (!differencesFound && orderMatches) {
  console.log("✅ URLs are IDENTICAL - Safe to use new implementation!");
} else {
  console.log("⚠️  URLs are DIFFERENT - Review differences above!");
  
  // Show exact character-by-character comparison
  console.log("\nCharacter comparison:");
  const minLen = Math.min(originalUrl.length, newUrl.length);
  for (let i = 0; i < minLen; i++) {
    if (originalUrl[i] !== newUrl[i]) {
      console.log(`  First difference at position ${i}:`);
      console.log(`    Original: "${originalUrl.substring(i, i + 20)}..."`);
      console.log(`    New:      "${newUrl.substring(i, i + 20)}..."`);
      break;
    }
  }
}