#!/bin/bash
set -euo pipefail

# get_schema.sh - Export PostgreSQL schema from Docker containers
# Usage:
#   ./get_schema.sh                                         # Interactive mode
#   ./get_schema.sh <server> <container> [options]         # Direct mode
#   ./get_schema.sh --help                                 # Show help

# Colors for output (matching migrate.sh)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Default values
DEFAULT_SERVER="wb-server"
DEFAULT_OUTPUT="schema.sql"
DEFAULT_USER="postgres"
DEFAULT_DATABASE=""
INTERACTIVE_MODE=false
EXPORT_TYPE="schema-only"

# Arguments
REMOTE_SERVER=""
CONTAINER_ID=""
OUTPUT_FILE=""
PG_USER=""
PG_DATABASE=""
PG_PASSWORD="${POSTGRES_PASSWORD:-}"

# Functions
log() {
    echo -e "${CYAN}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
}

log_success() {
    echo -e "${GREEN}✓${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

log_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

show_usage() {
    cat << EOF
${BOLD}get_schema.sh${NC} - Export PostgreSQL schema from Docker containers

${BOLD}USAGE:${NC}
    ./get_schema.sh                                    # Interactive mode
    ./get_schema.sh <server> <container> [options]    # Direct mode
    ./get_schema.sh --help                            # Show help

${BOLD}ARGUMENTS:${NC}
    server          SSH connection string (default: wb-server)
    container       Container name or ID (without -postgres suffix)

${BOLD}OPTIONS:${NC}
    --output <file>     Output file (default: schema.sql)
    --database <db>     Database name (required)
    --user <user>       PostgreSQL user (default: postgres)
    --password <pass>   PostgreSQL password (or use POSTGRES_PASSWORD env)
    --data-only        Export data without schema
    --full             Export both schema and data
    --table <name>     Export specific table(s)
    --exclude <pattern> Exclude tables matching pattern
    --help             Show this help message

${BOLD}EXAMPLES:${NC}
    # Interactive mode (prompts for all options)
    ./get_schema.sh

    # Direct mode with minimal options
    ./get_schema.sh wb-server nigeria --database mydb

    # Full export with custom output
    ./get_schema.sh prod-server haiti --full --output backup.sql

    # Export specific table
    ./get_schema.sh wb-server guinea --table users --database mydb

${BOLD}ENVIRONMENT:${NC}
    POSTGRES_PASSWORD    PostgreSQL password (alternative to --password)

EOF
}

parse_arguments() {
    # Check for help first
    if [[ "$#" -eq 0 ]]; then
        INTERACTIVE_MODE=true
        return 0
    fi

    if [[ "$1" == "--help" || "$1" == "-h" ]]; then
        show_usage
        exit 0
    fi

    # Parse positional arguments
    if [[ "$#" -ge 1 && ! "$1" =~ ^-- ]]; then
        REMOTE_SERVER="$1"
        shift
    fi

    if [[ "$#" -ge 1 && ! "$1" =~ ^-- ]]; then
        CONTAINER_ID="$1"
        shift
    fi

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --output|-o)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            --database|-d)
                PG_DATABASE="$2"
                shift 2
                ;;
            --user|-u)
                PG_USER="$2"
                shift 2
                ;;
            --password|-p)
                PG_PASSWORD="$2"
                shift 2
                ;;
            --data-only)
                EXPORT_TYPE="data-only"
                shift
                ;;
            --full)
                EXPORT_TYPE="full"
                shift
                ;;
            --table|-t)
                TABLE_FILTER="$2"
                shift 2
                ;;
            --exclude)
                EXCLUDE_PATTERN="$2"
                shift 2
                ;;
            --help|-h)
                show_usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
}

interactive_mode() {
    log_info "Interactive mode - Enter configuration"
    echo

    # Get server
    read -p "Remote server (default: $DEFAULT_SERVER): " server_input
    REMOTE_SERVER=${server_input:-$DEFAULT_SERVER}

    # Fetch and display containers
    log "Fetching containers from $REMOTE_SERVER..."

    # Look for wb-hmis containers specifically
    containers=$(ssh "$REMOTE_SERVER" "docker ps --format '{{.Names}}' | grep -E '^[^-]+-postgres$' | sed 's/-postgres$//' | sort" 2>/dev/null || true)

    if [ -z "$containers" ]; then
        # Fallback to all postgres containers
        containers=$(ssh "$REMOTE_SERVER" "docker ps --format '{{.Names}}' | grep -E 'postgres' | sort" 2>/dev/null || true)
    fi

    if [ -z "$containers" ]; then
        log_error "No PostgreSQL containers found on $REMOTE_SERVER"
        exit 1
    fi

    echo
    echo "${BOLD}Available containers:${NC}"
    echo "$containers" | nl -w2 -s'. '
    echo

    # Prompt for container selection
    read -p "Enter container number or name: " container_input

    # Check if input is a number
    if [[ "$container_input" =~ ^[0-9]+$ ]]; then
        CONTAINER_ID=$(echo "$containers" | sed -n "${container_input}p")
    else
        CONTAINER_ID="$container_input"
    fi

    if [ -z "$CONTAINER_ID" ]; then
        log_error "Invalid selection"
        exit 1
    fi

    # Get database name
    read -p "Database name: " db_input
    PG_DATABASE="$db_input"

    if [ -z "$PG_DATABASE" ]; then
        log_error "Database name is required"
        exit 1
    fi

    # Get output file
    read -p "Output file (default: $DEFAULT_OUTPUT): " output_input
    OUTPUT_FILE=${output_input:-$DEFAULT_OUTPUT}

    # Get PostgreSQL user
    read -p "PostgreSQL user (default: $DEFAULT_USER): " user_input
    PG_USER=${user_input:-$DEFAULT_USER}

    # Get export type
    echo
    echo "${BOLD}Export type:${NC}"
    echo "1. Schema only (default)"
    echo "2. Data only"
    echo "3. Full (schema + data)"
    read -p "Select export type [1-3]: " export_choice

    case "$export_choice" in
        2) EXPORT_TYPE="data-only" ;;
        3) EXPORT_TYPE="full" ;;
        *) EXPORT_TYPE="schema-only" ;;
    esac

    # Get password
    if [ -z "$PG_PASSWORD" ]; then
        read -s -p "PostgreSQL password: " pass_input
        echo
        PG_PASSWORD="$pass_input"
    fi
}

validate_inputs() {
    # Set defaults if not set
    OUTPUT_FILE=${OUTPUT_FILE:-$DEFAULT_OUTPUT}
    PG_USER=${PG_USER:-$DEFAULT_USER}

    # Validate required fields
    if [ -z "$REMOTE_SERVER" ]; then
        log_error "Server is required"
        show_usage
        exit 1
    fi

    if [ -z "$CONTAINER_ID" ]; then
        log_error "Container is required"
        show_usage
        exit 1
    fi

    if [ -z "$PG_DATABASE" ] && [ "$EXPORT_TYPE" != "schema-only" ]; then
        log_error "Database name is required for data exports"
        exit 1
    fi

    if [ -z "$PG_PASSWORD" ]; then
        log_error "PostgreSQL password required. Set POSTGRES_PASSWORD env or use --password"
        exit 1
    fi
}

test_connection() {
    log "Testing connection to $REMOTE_SERVER..."

    if ! ssh -o ConnectTimeout=10 -o BatchMode=yes "$REMOTE_SERVER" "echo 'Connected'" &> /dev/null; then
        log_error "Cannot connect to $REMOTE_SERVER via SSH"
        exit 1
    fi

    log_success "SSH connection successful"

    # Check container exists
    local postgres_container="${CONTAINER_ID}-postgres"

    if ! ssh "$REMOTE_SERVER" "docker ps --format '{{.Names}}' | grep -q '^${postgres_container}$'" 2>/dev/null; then
        # Try without -postgres suffix
        if ! ssh "$REMOTE_SERVER" "docker ps --format '{{.Names}}' | grep -q '^${CONTAINER_ID}$'" 2>/dev/null; then
            log_error "Container '$CONTAINER_ID' or '$postgres_container' not found"
            exit 1
        fi
        postgres_container="$CONTAINER_ID"
    fi

    log_success "Container '$postgres_container' found"
}

export_schema() {
    local postgres_container="${CONTAINER_ID}-postgres"

    # Check if we need to use the container without -postgres suffix
    if ! ssh "$REMOTE_SERVER" "docker ps --format '{{.Names}}' | grep -q '^${postgres_container}$'" 2>/dev/null; then
        postgres_container="$CONTAINER_ID"
    fi

    # Build pg_dump command based on export type
    local dump_cmd="pg_dump -U $PG_USER"

    if [ -n "$PG_DATABASE" ]; then
        dump_cmd="$dump_cmd -d $PG_DATABASE"
    fi

    case "$EXPORT_TYPE" in
        "schema-only")
            dump_cmd="$dump_cmd --schema-only"
            log "Exporting schema from '$postgres_container'..."
            ;;
        "data-only")
            dump_cmd="$dump_cmd --data-only"
            log "Exporting data from '$postgres_container'..."
            ;;
        "full")
            log "Exporting full database from '$postgres_container'..."
            ;;
    esac

    # Add table filter if specified
    if [ -n "${TABLE_FILTER:-}" ]; then
        dump_cmd="$dump_cmd -t '$TABLE_FILTER'"
    fi

    # Add exclude pattern if specified
    if [ -n "${EXCLUDE_PATTERN:-}" ]; then
        dump_cmd="$dump_cmd --exclude-table='$EXCLUDE_PATTERN'"
    fi

    # Execute export
    if ssh "$REMOTE_SERVER" "docker exec $postgres_container sh -c 'PGPASSWORD=$PG_PASSWORD $dump_cmd'" > "$OUTPUT_FILE" 2>/dev/null; then
        # Check if output file has content
        if [ -s "$OUTPUT_FILE" ]; then
            local file_size=$(du -h "$OUTPUT_FILE" | cut -f1)
            log_success "Export completed successfully"
            log_info "Output file: $OUTPUT_FILE ($file_size)"

            # Show summary
            if [[ "$EXPORT_TYPE" == "schema-only" ]]; then
                local table_count=$(grep -c "CREATE TABLE" "$OUTPUT_FILE" 2>/dev/null || echo "0")
                log_info "Tables exported: $table_count"
            fi
        else
            log_error "Export produced empty file"
            rm -f "$OUTPUT_FILE"
            exit 1
        fi
    else
        log_error "Export failed"
        rm -f "$OUTPUT_FILE"
        exit 1
    fi
}

# Main execution
main() {
    parse_arguments "$@"

    if [ "$INTERACTIVE_MODE" = true ]; then
        interactive_mode
    fi

    validate_inputs
    test_connection
    export_schema
}

# Run main function
main "$@"